/*
 * File: ToolbarController.java
 * Names: Kevin Ahn, Matt Jones, Jackie Hang, Kevin Zhou
 * Class: CS 361
 * Project 4
 * Date: October 2, 2018
 * ---------------------------
 * Edited By: Zena Abulhab, Paige Hanssen, Kyle Slager, Kevin Zhou
 * Project 5
 * Date: October 12, 2018
 * ---------------------------
 * Edited By: Zeb Keith-Hardy, Michael Li, Iris Lian, Kevin Zhou
 * Project 6/7/9
 * Date: October 26, 2018/ November 3, 2018/ November 20, 2018
 *  ---------------------------
 * Edited By: Zeb Keith-Hardy, Danqing Zhao, Tia Zhang
 * Class: CS 461
 * Project 11
 * Date: February 13, 2019
 *  ---------------------------
 * Edited By: Tia Zhang and Danqing Zhao
 * Class: CS 461
 * Project 12
 * Date: February 25, 2019
 */

package proj18DouglasMacDonaldZhang;

import javafx.application.Platform;
import javafx.geometry.Side;
import javafx.scene.control.Alert;
import org.fxmisc.richtext.CodeArea;
import proj18DouglasMacDonaldZhang.bantam.ast.Program;
import proj18DouglasMacDonaldZhang.bantam.parser.Parser;
import proj18DouglasMacDonaldZhang.bantam.semant.*;
import proj18DouglasMacDonaldZhang.bantam.treedrawer.Drawer;
import proj18DouglasMacDonaldZhang.bantam.util.ClassTreeNode;
import proj18DouglasMacDonaldZhang.bantam.util.CompilationException;
import proj18DouglasMacDonaldZhang.bantam.util.ErrorHandler;
import proj18DouglasMacDonaldZhang.bantam.util.Error;
import proj18DouglasMacDonaldZhang.bantam.lexer.Scanner;
import proj18DouglasMacDonaldZhang.bantam.lexer.Token;
import proj18DouglasMacDonaldZhang.bantam.semant.SemanticAnalyzer;

import java.util.*;
import java.util.concurrent.*;

import javafx.concurrent.Task;
import javafx.concurrent.Service;
import proj18DouglasMacDonaldZhang.bantam.codegenmips.MipsCodeGenerator;


import java.io.File;
import java.io.BufferedReader;
import java.io.*;


/**
 * This class is the controller for all of the toolbar functionality.
 * Specifically, the compile, compile and run, and stop buttons
 *
 * @author  Zeb Keith-Hardy, Michael Li, Iris Lian, Kevin Zhou
 * @author  Kevin Ahn, Jackie Hang, Matt Jones, Kevin Zhou
 * @author  Zena Abulhab, Paige Hanssen, Kyle Slager Kevin Zhou
 * @version 2.0
 * @since   10-3-2018
 *
 */
public class ToolbarController {

    private boolean scanIsDone;
    private boolean parseIsDone;
    private Console console;
    private CodeTabPane codeTabPane;
    private String tokenString;
    private Integer errorCounter = 0;
    private Program ast = null; //Stores the most recent ast generated by parsing - Tia addition
    private Hashtable<String, ClassTreeNode> classMap;
    //private ByteArrayOutputStream outputStream;



    /**
     * Process currently compiling or running a MIPS file
     */
    private Process curProcess;
    /**
     * Thread representing the MIPS program input stream
     */
    private Thread inThread;
    /**
     * Thread representing the MIPS program output stream
     */
    private Thread outThread;

    /**
     * Mutex lock to control input and output threads' access to console
     */
    private Semaphore mutex;
    /**
     * The consoleLength of the output on the console
     */
    private int consoleLength;


    /**
     * A CompileWorker object compiles a MIPS file in a separate thread.
     */
    private CompileWorker compileWorker;


    /**
     * A CompileRunWorker object compiles and runs a MIPS file in a separate thread.
     */
    private CompileRunWorker compileRunWorker;




    /**
     * This is the constructor of ToolbarController.
     * @param console the console
     * @param codeTabPane the tab pane
     */
    public ToolbarController(Console console, CodeTabPane codeTabPane){
        this.console = console;
        this.codeTabPane = codeTabPane;
        this.scanIsDone = true;
        this.parseIsDone = true;


        this.mutex = new Semaphore(1);
        this.compileWorker = new CompileWorker();
        this.compileRunWorker = new CompileRunWorker();
    }

    /**
     * Handles actions for scan or scanParse buttons
     * @param method type of button clicked on the toolbar
     */
    public void handleScanOrScanParse(String method, boolean errorMode, String additionalFunc){
        if(method.equals("scan")){
            this.handleScan();
        }else{
            this.handleParsing(method, errorMode, additionalFunc);
        }
    }

    /**
     * Handles scanning the current CodeArea, prints results to a new code Area.
     */
    public void handleScan(){
        this.scanIsDone = false;
        //declare a new thread and assign it with the work of scanning the current tab
        new Thread(()-> {
            ScanTask scanTask = new ScanTask();
            FutureTask<String> curFutureTask = new FutureTask<>(scanTask);
            ExecutorService curExecutor = Executors.newFixedThreadPool(1);
            curExecutor.execute(curFutureTask);
        }).start();
    }



    //TODO fix this so it's not doing so much in one method
    /**
     * creates a new finder thread for parsing the AST.
     * Once AST is parsed, checks the type of finder and then passes the AST to the correct one.
     * default case draws the AST
     * @param method type of finder being executed
     * @param errorMode dictates whether errors from semantic analysis should be printed
     * @param additionalFunc is a String indicating an additional function to be run after semantic analysis.
     * Options are "uses", "unused", and "suggestions"
     * Pass in null if no additional functions are needed
     */
    public void handleParsing(String method, boolean errorMode, String additionalFunc){
        this.parseIsDone = false;
        new Thread (()->{
            ParseTask parseTask = new ParseTask();
            FutureTask<Program> curFutureTask = new FutureTask<Program>(parseTask);
            ExecutorService curExecutor = Executors.newFixedThreadPool(1);
            curExecutor.execute(curFutureTask);
            try{
                Program AST = curFutureTask.get();
                if(AST != null){
                    ast = AST;
                    switch(method){

                        //scan, parse, and check button clicked
                        case "semanticCheck":
                            ErrorHandler errorHandler = new ErrorHandler();
                            SemanticAnalyzer semantAnalyzer = new SemanticAnalyzer(errorHandler);
                            semantAnalyzer.analyze(AST);
                            classMap = semantAnalyzer.getClassMap();
                            Hashtable<String, ClassTreeNode> map = semantAnalyzer.getClassMap();




                            Platform.runLater(() -> {
                                ToolbarController.this.console.writeToConsole("There were: " +
                                        errorHandler.getErrorList().size() + " semantic errors in " +
                                        ToolbarController.this.codeTabPane.getFileName() + "\n", "Output");

                                if (errorHandler.errorsFound() && errorMode) {
                                    ToolbarController.this.console.writeToConsole("Semantic Analysis Failed\n", "Error");
                                    List<Error> errorList = errorHandler.getErrorList();
                                    Iterator<Error> errorIterator = errorList.iterator();
                                    ToolbarController.this.console.writeToConsole("\n", "Error");
                                    while (errorIterator.hasNext()) {
                                        ToolbarController.this.console.writeToConsole(errorIterator.next().toString() +
                                                "\n", "Error");
                                    }
                                }
                            });


                            if(additionalFunc != null){
                                switch (additionalFunc) {
                                    case "uses":
                                        handleFindUses();
                                        break;

                                    case "unused":
                                        handleFindUnused();
                                        break;
                                    case "suggestions":
                                        handleSuggestions();
                                        break;
                                    case "compile":

                                        ClassTreeNode objectNode = classMap.get("Object");
                                        //TODO ask what if you already have a MIPS file with the same name as the Bantam?
                                        ///Main is the only class that I can guarantee will exist without being built in
                                        String fileName = classMap.get("Main").getASTNode().getFilename();
                                        //Get rid of the .btm extension
                                        fileName = fileName.substring(0, fileName.length()-4);
                                        compileToMips(objectNode, ast, errorHandler, fileName);
                                        break;
                                }

                            }
                            break;

                        case "parseOnly":
                            System.out.println("AST is " + ast + " " + AST);
                            break;
                        //scan and parse clicked, build AST image
                        default:
                            Drawer drawer = new Drawer();
                            drawer.draw(this.codeTabPane.getFileName(),AST);
                            break;
                    }
                }
                this.parseIsDone = true;
            }catch(InterruptedException| ExecutionException e){
                Platform.runLater(()-> this.console.writeToConsole("Parsing failed \n", "Error"));
            }
        }).start();
    }

    /**
     * Check if the scan task is still running.
     * @return true if this task is done, and false otherwise
     */
    public boolean scanIsDone(){
        return this.scanIsDone;
    }

    /**
     * Check if the parse task is still running.
     * @return true if this task is done, and false otherwise
     */
    public boolean parseIsDone(){
        return this.parseIsDone;
    }


    /*
     * Find and prints all the usages of a user-selected highlighted variable in the console
     * Must be called in a separate thread from the main.
     * Semantic analysis must've occurred before this happens
     */
    public void handleFindUses() {

        if (ast != null) { //Just in case and to make it more flexible
            String selectedText = codeTabPane.getCodeArea().getSelectedText();
            FindDeclarationUsesVisitor findDeclarationUses = new FindDeclarationUsesVisitor();
            findDeclarationUses.setJavaTabPane(selectedText);
            findDeclarationUses.handleFindUses(ast);
            Platform.runLater(() -> {
                console.writeToConsole("Uses of " + selectedText + ": \n" + findDeclarationUses.getUses(),"output");
                console.writeToConsole("Finding uses completed successfully \n","output");

            });
        }
    }






    /*
     * Find and prints all the unused identifiers in a program.
     * Must be called in a separate thread from the main.
     * Semantic analysis must've occurred before this happens
     */
    public void handleFindUnused() {

        if (ast != null) {
            BuildUsesMapVisitor usesMapVisitor = new BuildUsesMapVisitor(classMap);
            Hashtable<ClassTreeNode, Hashtable<String, IdentifierInfo>> classUsesMap = usesMapVisitor.makeMap(ast);
            ArrayList<String> scopeNamesList = usesMapVisitor.getScopeNameList();
            FindUnusedVisitor findUnused = new FindUnusedVisitor(classMap, classUsesMap, scopeNamesList);
            String unused = findUnused.checkForUnused(ast);
            Platform.runLater(() -> {
                console.writeToConsole(unused, "output");
            });

        }
    }

    /*
     * When the user has selected text, finds any identifiers (classes, methods, variables).that has the same beginning
     * and displays them as a context menu to the side so it does not obstruct their view. Selecting any of those
     * items will autocomplete the highlighted text with the full version of its name.
     * The context menu can be closed by clicking on a diff section of the tab pane (not on the code area)
     * or hitting the escape key.
     * Must be called in a separate thread from the main.
     * Semantic analysis must've occurred before this happens
     */
    public void handleSuggestions(){

        CodeArea curCodeArea = codeTabPane.getCodeArea();
        String beginning = curCodeArea.getSelectedText();
        if(beginning.length() < 1){
            return;
        }

        if(ast != null) { //Just in case. Should never happen, but just in case and make it more flexible
            //System.out.println("AST isn't null");
            FindIDsVisitor idVisitor = new FindIDsVisitor(classMap);
            ArrayList<IdentifierInfo> idList = idVisitor.collectIdentifiers(ast);
            System.out.println("Found " + idList.size() + " ids");
            findPossibleVars(idList, beginning, curCodeArea);
        }

    }

    /*
     * Finds all the identifiers that begins with the same letters as the given string
     * Makes a menu to display those identifiers that match.
     * @param idList is an array list of all the identifiers to check. It should contain IdentifierInfo objects
     * @param beginning is the String that should be matched with existing identifiers
     * @param curCodeArea is the code area that the selected text is in
     * This function must be run in a separate thread from the main
     */
    private void findPossibleVars(ArrayList<IdentifierInfo> idList, String beginning, CodeArea curCodeArea){
        ArrayList<IdentifierInfo> possibleNames = new ArrayList<IdentifierInfo>();
        idList.forEach((idInfo) -> {
                    if(idInfo.getName().startsWith(beginning)){
                        possibleNames.add(idInfo);
                        System.out.println("Suggestions " + idInfo.getName());
                    }
                }
        );

        Platform.runLater( ()->{
                    SuggestionsContextMenu suggestionsMenu = new SuggestionsContextMenu(possibleNames, curCodeArea);
                    suggestionsMenu.show(curCodeArea, Side.RIGHT, curCodeArea.getCaretPosition(), curCodeArea.getCaretColumn());
                }
        );

    }




    /**
     * An inner class used to parse a file in a separate thread.
     * Prints error info to the console
     */
    private class ParseTask implements Callable{

        /**
         * Create a Parser and use it to create an AST
         * @return AST tree created by a parser
         */
        @Override
        public Program call(){
            ErrorHandler errorHandler = new ErrorHandler();
            Parser parser = new Parser(errorHandler);
            String filename = ToolbarController.this.codeTabPane.getFileName();
            Program AST = null;
            try{
                AST = parser.parse(filename);
                Platform.runLater(()->ToolbarController.this.console.writeToConsole(
                        "Parsing Successful.\n", "Output"));
            }
            catch (CompilationException e){
                Platform.runLater(()-> {
                    ToolbarController.this.console.writeToConsole("Parsing Failed\n","Error");
                    ToolbarController.this.console.writeToConsole("There were: " +
                            errorHandler.getErrorList().size() + " errors in " +
                            ToolbarController.this.codeTabPane.getFileName() + "\n", "Output");

                    if (errorHandler.errorsFound()) {
                        List<Error> errorList = errorHandler.getErrorList();
                        Iterator<Error> errorIterator = errorList.iterator();
                        ToolbarController.this.console.writeToConsole("\n", "Error");
                        while (errorIterator.hasNext()) {
                            ToolbarController.this.console.writeToConsole(errorIterator.next().toString() +
                                    "\n", "Error");
                        }
                    }
                });
            }
            return AST;
        }
    }

    /**
     * A private inner class used to scan a file in a separate thread
     * Print error messages to the console and write tokens in a new tab
     */
    private class ScanTask implements Callable {
        /**
         * Start the process by creating a scanner and use it to scan the file
         * @return a result string containing information about all the tokens
         */
        @Override
        public String call(){
            ErrorHandler errorHandler = new ErrorHandler();
            Scanner scanner = new Scanner(ToolbarController.this.codeTabPane.getFileName(), errorHandler);
            Token token = scanner.scan();
            StringBuilder tokenString = new StringBuilder();

            while(token.kind != Token.Kind.EOF){
                tokenString.append(token.toString() + "\n");
                token = scanner.scan();
            }
            String resultString = tokenString.toString();
            Platform.runLater(()-> {
                ToolbarController.this.console.writeToConsole("There were: " +
                        errorHandler.getErrorList().size() + " errors in " +
                        ToolbarController.this.codeTabPane.getFileName() + "\n","Output");
                if(errorHandler.errorsFound()){
                    List<Error> errorList= errorHandler.getErrorList();
                    Iterator<Error> errorIterator = errorList.iterator();
                    ToolbarController.this.console.writeToConsole("\n","Error");

                    while(errorIterator.hasNext()){
                        ToolbarController.this.console.writeToConsole(
                                errorIterator.next().toString() + "\n","Error");
                    }
                }
                ToolbarController.this.codeTabPane.createTabWithContent(resultString);
                ToolbarController.this.scanIsDone = true;
            });
            return tokenString.toString();
        }
    }

    /**
     * A private inner class used to scan a file in a separate thread
     * Print error messages to the console and write tokens in a new tab
     */
    private class MIPSTask implements Callable {
        /**
         * Start the process by creating a scanner and use it to scan the file
         * @return a result string containing information about all the tokens
         */
        @Override
        public String call(){
            ErrorHandler errorHandler = new ErrorHandler();
            Scanner scanner = new Scanner(ToolbarController.this.codeTabPane.getFileName(), errorHandler);
            Token token = scanner.scan();
            StringBuilder tokenString = new StringBuilder();

            while(token.kind != Token.Kind.EOF){
                tokenString.append(token.toString() + "\n");
                token = scanner.scan();
            }
            String resultString = tokenString.toString();
            Platform.runLater(()-> {
                ToolbarController.this.console.writeToConsole("There were: " +
                        errorHandler.getErrorList().size() + " errors in " +
                        ToolbarController.this.codeTabPane.getFileName() + "\n","Output");
                if(errorHandler.errorsFound()){
                    List<Error> errorList= errorHandler.getErrorList();
                    Iterator<Error> errorIterator = errorList.iterator();
                    ToolbarController.this.console.writeToConsole("\n","Error");

                    while(errorIterator.hasNext()){
                        ToolbarController.this.console.writeToConsole(
                                errorIterator.next().toString() + "\n","Error");
                    }
                }
                ToolbarController.this.codeTabPane.createTabWithContent(resultString);
                ToolbarController.this.scanIsDone = true;
            });
            return tokenString.toString();
        }
    }



    private void compileToMips(ClassTreeNode objectNode, Program ast, ErrorHandler errorHandler, String outFile){
        MipsCodeGenerator mipsGenerator = new MipsCodeGenerator(errorHandler, false, false);
        mipsGenerator.generate(objectNode, ast, outFile + ".asm");
//        for (File file: this.codeTabPane.getCurrentFile().listFiles()) {
//
//            System.out.println(file.getName());
//        }
//        File newFile = new File(outFile + ".asm");
//        this.codeTabPane.makeTabFromFile(newFile, true);
        Platform.runLater(()-> {
            File newFile = new File(outFile + ".asm");
            this.codeTabPane.makeTabFromFile(newFile, true);
        });
    }




    /*
    * Creates an error dialogue box
    * @param errorTitle is the kind of error it is. The word "Error" will be added to it and that will be the title of the box
    * @param errorString is the message that appears in the box
    */
    public void createErrorDialog(String errorTitle, String errorString)
    {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle(errorTitle + " Error");
        alert.setHeaderText("Error for " + errorTitle);
        alert.setContentText(errorString);
        alert.showAndWait();
    }



    /**
     * Helper method for running MIPS Compiler/assembly.
     */
    private boolean compileMIPSFile(File file) {
        try {
            Platform.runLater(() -> {
                this.console.clear();
                this.consoleLength = 0;
            });

            ArrayList<String> pbArgs = new ArrayList<String>();
            pbArgs.add("java");
            pbArgs.add("-jar");
            //pbArgs.add("\\include\\Mars4_5.jar"); //NOT WORKING AGAIN
            pbArgs.add("/Users/wyettmacdonald/Documents/Spring_19/CS461/CS461_Project13/Proj13/src/proj18DouglasMacDonaldZhang/include/Mars4_5.jar");
            pbArgs.add("/Users/wyettmacdonald/Documents/Spring_19/CS461/CS461_Project13/Proj13/src/proj18DouglasMacDonaldZhang/include/exceptions.s");
            pbArgs.add("a");
            pbArgs.add(file.getAbsolutePath());
            ProcessBuilder pb = new ProcessBuilder(pbArgs);
            console.setProcessActive(true);
            this.curProcess = pb.start();

            this.outputToConsole();

            // true if compiled without compile-time error, else false
            return this.curProcess.waitFor() == 0;
        } catch (Throwable e) {
            Platform.runLater(() -> {
                createErrorDialog("File Compilation", "Error compiling.\nPlease try again with another valid Java File.");
                console.setProcessActive(false);
            });
            return false;
        }
    }

    /**
     * Helper method for running Java Program.
     */
    private boolean compileAndRunMIPSFile(File file) {
        try {
            Platform.runLater(() -> {
                this.console.clear();
                consoleLength = 0;
            });
            ArrayList<String> pbArgs = new ArrayList<String>();
            pbArgs.add("java");
            pbArgs.add("-jar");
            pbArgs.add("\\include\\Mars4_5.jar"); //NOT WORKING AGAIN
//            pbArgs.add("C:\\Users\\Tear\\Downloads\\CS361-proj13\\Proj13\\src\\proj18DouglasMacDonaldZhang\\include\\Mars4_5.jar");
            pbArgs.add(file.getAbsolutePath());
            ProcessBuilder pb = new ProcessBuilder(pbArgs);
            console.setProcessActive(true);
            this.curProcess = pb.start();

            // Start output and input in different threads to avoid deadlock
            this.outThread = new Thread() {
                public void run() {
                    try {
                        // start output thread first
                        mutex.acquire();
                        outputToConsole();
                    } catch (Throwable e) {
                        Platform.runLater(() -> {
                            // print stop message if other thread hasn't
                            if (consoleLength == console.getLength()) {
                                console.appendText("\nProgram exited unexpectedly\n");
                                console.requestFollowCaret();
                                console.setProcessActive(false);
                            }
                        });
                    }
                }
            };
            outThread.start();

            inThread = new Thread() {
                public void run() {
                    try {
                        inputFromConsole();
                    } catch (Throwable e) {
                        Platform.runLater(() -> {
                            // print stop message if other thread hasn't
                            if (consoleLength == console.getLength()) {
                                console.appendText("\nProgram exited unexpectedly\n");
                                console.requestFollowCaret();
                                console.setProcessActive(false);
                            }
                        });
                    }
                }
            };
            inThread.start();

            // true if ran without error, else false
            return curProcess.waitFor() == 0;
        } catch (Throwable e) {
            Platform.runLater(() -> {
                createErrorDialog("File Running", "Error running " + file.getName() + ".");
                console.setProcessActive(false);
            });
            return false;
        }
    }

    /**
     * Helper method for getting program output
     */
    private void outputToConsole() throws java.io.IOException, java.lang.InterruptedException {
        InputStream stdout = this.curProcess.getInputStream();
        InputStream stderr = this.curProcess.getErrorStream();

        BufferedReader outputReader = new BufferedReader(new InputStreamReader(stdout));
        printOutput(outputReader);

        BufferedReader errorReader = new BufferedReader(new InputStreamReader(stderr));
        printOutput(errorReader);
    }

    /**
     * Helper method for getting program input
     */
    public void inputFromConsole() throws IOException, InterruptedException {
        OutputStream stdin = curProcess.getOutputStream();
        BufferedWriter inputWriter = new BufferedWriter(new OutputStreamWriter(stdin));

        while (curProcess.isAlive()) {
            // wait until signaled by output thread
            this.mutex.acquire();
            // write input to program
            writeInput(inputWriter);
            // signal output thread
            this.mutex.release();
            // wait for output to acquire mutex
            Thread.sleep(500); //Increasing the Thread sleep time seems to have fixed the double input writing
        }
        console.setProcessActive(false);
        inputWriter.close();
    }

    /**
     * Helper method for printing to console
     *
     * @throws java.io.IOException
     * @throws java.lang.InterruptedException
     */
    private void printOutput(BufferedReader reader) throws java.io.IOException, java.lang.InterruptedException {
        // if the output stream is paused, signal the input thread
        if (!reader.ready()) {
            this.mutex.release();
        }

        int intch;
        // read in program output one character at a time
        while ((intch = reader.read()) != -1) {
            this.mutex.tryAcquire();
            char ch = (char) intch;
            String out = Character.toString(ch);
            Platform.runLater(() -> {
                // add output to console
                this.console.appendText(out);
                this.console.requestFollowCaret();
            });
            // update console length tracker to include output character
            this.consoleLength++;

            // if the output stream is paused, signal the input thread
            if (!reader.ready()) {
                this.mutex.release();
            }
            // wait for input thread to acquire mutex if necessary
            Thread.sleep(1);
        }
        this.mutex.release();
        reader.close();
    }


    /**
     * Helper function to write user input
     */
    public void writeInput(BufferedWriter writer) throws java.io.IOException {
        // wait for user to input line of text
        while (true) {
            if (this.console.getLength() > this.consoleLength) {
                // check if user has hit enter
                if (this.console.getText().substring(this.consoleLength).contains("\n")) {
                    //System.out.println("New line on console");
                    break;
                }
            }
        }
        // write user-entered text to program input
        System.out.println(this.console.getText().substring(this.consoleLength) + " will be written to the process");
        writer.write(this.console.getText().substring(this.consoleLength));
        writer.flush();
        // update console length to include user input
        this.consoleLength = this.console.getLength();
    }

    /**
     * Handles the Assemble button action.
     *
     * @param file  the Selected file
     */
    public void handleAssemble(File file) {
        // user select cancel button

            compileWorker.setFile(file);
            compileWorker.restart();

    }

    /**
     * Handles the Assemble and Run button action.
     *
     * @param file  the Selected file
     */
    public void handleAssembleAndRun(File file) {
        // user select cancel button
            compileRunWorker.setFile(file);
            compileRunWorker.restart();
    }

    /**
     * Handles the Stop button action.
     */
    public void handleStop() {
        try {
            if (this.curProcess.isAlive()) {
                this.inThread.interrupt();
                this.outThread.interrupt();
                this.curProcess.destroy();
                console.writeToConsole("Terminated MIPS program", "processInfo");
            }
        } catch (Throwable e) {
            createErrorDialog("Program Stop", "Error stopping the MIPS program.");
        }
    }

    /**
     * A CompileWorker subclass handling MIPS program compiling in a separated thread in the background.
     * CompileWorker extends the javafx Service class.
     */
    protected class CompileWorker extends Service<Boolean> {
        /**
         * the file to be compiled.
         */
        private File file;

        /**
         * Sets the selected file.
         *
         * @param file the file to be compiled.
         */
        private void setFile(File file) {
            this.file = file;
        }

        /**
         * Overrides the createTask method in Service class.
         * Compiles the file embedded in the selected tab, if appropriate.
         *
         * @return true if the program compiles successfully;
         * false otherwise.
         */
        @Override
        protected Task<Boolean> createTask() {
            return new Task<Boolean>() {
                /**
                 * Called when we execute the start() method of a CompileRunWorker object
                 * Compiles the file.
                 *
                 * @return true if the program compiles successfully;
                 *         false otherwise.
                 */
                @Override
                protected Boolean call() {
                    Boolean compileResult = compileMIPSFile(file);
                    if (compileResult) {
                        Platform.runLater(() -> console.appendText("Compilation was successful!\n"));
                    }
                    return compileResult;
                }
            };
        }
    }

    /**
     * A CompileRunWorker subclass handling MIPS program compiling and running in a separated thread in the background.
     * CompileWorker extends the javafx Service class.
     */
    protected class CompileRunWorker extends Service<Boolean> {
        /**
         * the file to be compiled.
         */
        private File file;

        /**
         * Sets the selected file.
         *
         * @param file the file to be compiled.
         */
        private void setFile(File file) {
            this.file = file;
        }

        /**
         * Overrides the createTask method in Service class.
         * Compiles and runs the file embedded in the selected tab, if appropriate.
         *
         * @return true if the program runs successfully;
         * false otherwise.
         */
        @Override
        protected Task<Boolean> createTask() {
            return new Task<Boolean>() {
                /**
                 * Called when we execute the start() method of a CompileRunWorker object.
                 * Compiles the file and runs it if compiles successfully.
                 *
                 * @return true if the program runs successfully;
                 *         false otherwise.
                 */
                @Override
                protected Boolean call() {
                    //if (compileMIPSFile(file)) {
                        return compileAndRunMIPSFile(file);
                    //}
                    //return false;
                }
            };
        }
    }
}